
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ruuvi_driver_sensor.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#ifndef RUUVI_DRIVER_SENSOR_H</a>
<a name="ln2">#define RUUVI_DRIVER_SENSOR_H</a>
<a name="ln3">/**</a>
<a name="ln4"> * @defgroup Sensor Common sensor interface</a>
<a name="ln5"> * @brief Functions for setting up and using sensors</a>
<a name="ln6"> *</a>
<a name="ln7"> *</a>
<a name="ln8"> */</a>
<a name="ln9">/*@{*/</a>
<a name="ln10">/**</a>
<a name="ln11"> * @file ruuvi_driver_sensor.h</a>
<a name="ln12"> * @author Otso Jousimaa &lt;otso@ojousima.net&gt;</a>
<a name="ln13"> * @date 2019-10-10</a>
<a name="ln14"> * @copyright Ruuvi Innovations Ltd, license BSD-3-Clause</a>
<a name="ln15"> * @brief Ruuvi sensor interface &lt;b&gt;Lifecycle: Beta&lt;/b&gt;</a>
<a name="ln16"> *</a>
<a name="ln17"> *  </a>
<a name="ln18"> *</a>
<a name="ln19"> * Common interface to all Ruuvi Sensors</a>
<a name="ln20"> * Every sensor must implement these functions:</a>
<a name="ln21"> * - init</a>
<a name="ln22"> * - uninit</a>
<a name="ln23"> * - samplerate_set</a>
<a name="ln24"> * - samplerate_get</a>
<a name="ln25"> * - dsp_set</a>
<a name="ln26"> * - dsp_get</a>
<a name="ln27"> * - scale_set</a>
<a name="ln28"> * - scale_set</a>
<a name="ln29"> * - resolution_set</a>
<a name="ln30"> * - resolution_get</a>
<a name="ln31"> * - mode_set</a>
<a name="ln32"> * - mode_get</a>
<a name="ln33"> * - data_get</a>
<a name="ln34"> *</a>
<a name="ln35"> * If function does not make sense for the sensor, it will return error code.</a>
<a name="ln36"> *</a>
<a name="ln37"> * Return name: Return a pointer to a constant 8-byte long string which represensts sensor, e.g. LIS2DH12\0 or BME280\0\0</a>
<a name="ln38"> *</a>
<a name="ln39"> * INIT, UNINT: Init will prepare sensor for use, reset the sensor, run self-test and place it in low-power mode. Additionally function pointers will be set up by init.</a>
<a name="ln40"> *              Uninit will release any resources used by sensor</a>
<a name="ln41"> *</a>
<a name="ln42"> * Samplerate: Applicable on continuous mode, how often sensor takes samples. Hz</a>
<a name="ln43"> *</a>
<a name="ln44"> * DSP: DSP function and parameter, i.e. &quot;OVERSAMPLING, 16&quot;. Return error if the device does not support it.</a>
<a name="ln45"> *</a>
<a name="ln46"> * scale: Maximum scale in a meaningful physical unit, such as celcius or pascal.</a>
<a name="ln47"> *</a>
<a name="ln48"> * resolution: Resolution in bits.</a>
<a name="ln49"> *</a>
<a name="ln50"> * mode: Sleep, single, continuous.</a>
<a name="ln51"> *  - Sleep mode should enter lowest-power state available</a>
<a name="ln52"> *  - Single will return once new data is available with data_get call</a>
<a name="ln53"> *  - Continuous: Sensor will sample at given rate. Returns immediately, data will be available after first sample</a>
<a name="ln54"> *</a>
<a name="ln55"> * data get: return latest sample from sensor</a>
<a name="ln56"> */</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;ruuvi_driver_error.h&quot;</a>
<a name="ln59">#include &lt;stdbool.h&gt;</a>
<a name="ln60">#include &lt;stddef.h&gt;</a>
<a name="ln61">#include &lt;stdint.h&gt;</a>
<a name="ln62"> </a>
<a name="ln63">#define RUUVI_DRIVER_SENSOR_INVALID_VALUE    RUUVI_DRIVER_FLOAT_INVALID  //!&lt; Signal this sensor value is erroneous</a>
<a name="ln64">#define RUUVI_DRIVER_SENSOR_INVALID_TIMSTAMP RUUVI_DRIVER_UINT64_INVALID //!&lt; Signal this timestamp value is erroneous</a>
<a name="ln65"> </a>
<a name="ln66">// Constants for sensor configuration and status</a>
<a name="ln67">#define RUUVI_DRIVER_SENSOR_CFG_DEFAULT         0      //!&lt; Default value, always valid for the sensor.</a>
<a name="ln68">#define RUUVI_DRIVER_SENSOR_CFG_CUSTOM_1        0xC9   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln69">#define RUUVI_DRIVER_SENSOR_CFG_CUSTOM_2        0xCA   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln70">#define RUUVI_DRIVER_SENSOR_CFG_CUSTOM_3        0xCB   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln71">#define RUUVI_DRIVER_SENSOR_CFG_CUSTOM_4        0xCC   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln72">#define RUUVI_DRIVER_SENSOR_CFG_CUSTOM_5        0xCD   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln73">#define RUUVI_DRIVER_SENSOR_CFG_CUSTOM_6        0xCE   //!&lt; Configuration range is 0...200, i.e. 0 ... 0xC8. Use C9 ... CF as sensor-specific values.</a>
<a name="ln74">#define RUUVI_DRIVER_SENSOR_ERR_INVALID         0xE0   //!&lt; Error code, given parameter is invalid</a>
<a name="ln75">#define RUUVI_DRIVER_SENSOR_ERR_NOT_IMPLEMENTED 0xE1   //!&lt; Error code, given parameter is not implemented (todo)</a>
<a name="ln76">#define RUUVI_DRIVER_SENSOR_ERR_NOT_SUPPORTED   0xE2   //!&lt; Error code, given parameter is not supported by sensor</a>
<a name="ln77">#define RUUVI_DRIVER_SENSOR_CFG_MIN             0xF0   //!&lt; Configure smallest supported and implemented value</a>
<a name="ln78">#define RUUVI_DRIVER_SENSOR_CFG_MAX             0xF1   //!&lt; Configure largest supported and implemented value</a>
<a name="ln79">#define RUUVI_DRIVER_SENSOR_CFG_SLEEP           0xF2   //!&lt; Sensor should go to sleep immediately</a>
<a name="ln80">#define RUUVI_DRIVER_SENSOR_CFG_SINGLE          0xF3   //!&lt; Sensor should go to sleep after single measurement</a>
<a name="ln81">#define RUUVI_DRIVER_SENSOR_CFG_CONTINUOUS      0xF4   //!&lt; Sensor will keep sampling at defined sample rate</a>
<a name="ln82">#define RUUVI_DRIVER_SENSOR_CFG_NO_CHANGE       0xFF   //!&lt; Do not change configured value</a>
<a name="ln83"> </a>
<a name="ln84">// DSP functions, complemented by DSP parameter</a>
<a name="ln85">#define RUUVI_DRIVER_SENSOR_DSP_LAST            0      //!&lt; Return last value from sesnor. Parameter: No effect. Use default</a>
<a name="ln86">#define RUUVI_DRIVER_SENSOR_DSP_LOW_PASS        (1&lt;&lt;1) //!&lt; Low pass sensor values Parameter: coefficient</a>
<a name="ln87">#define RUUVI_DRIVER_SENSOR_DSP_HIGH_PASS       (1&lt;&lt;2) //!&lt; High pass sensor values Parameter: coefficient</a>
<a name="ln88">#define RUUVI_DRIVER_SENSOR_DSP_OS              (1&lt;&lt;3) //!&lt; Oversample sensor values. Parameter: Number of samples</a>
<a name="ln89"> </a>
<a name="ln90">/** @brief convert Ruuvi GPIO into uint8_t */</a>
<a name="ln91">#define RUUVI_DRIVER_GPIO_TO_HANDLE(handle) ((((handle) &gt;&gt; 3) &amp; 0xE0) + ((handle) &amp; 0x1F))</a>
<a name="ln92">/** @brief convert uint8_t into Ruuvi GPIO */</a>
<a name="ln93">#define RUUVI_DRIVER_HANDLE_TO_GPIO(handle) ((((handle) &amp; 0xE0) &lt;&lt; 3) + ((handle) &amp; 0x1F))</a>
<a name="ln94"> </a>
<a name="ln95">/**</a>
<a name="ln96"> * @brief All sensors must implement configuration functions which accepts this struct.</a>
<a name="ln97"> */</a>
<a name="ln98">typedef struct __attribute__((packed, aligned(4)))</a>
<a name="ln99">{</a>
<a name="ln100">  uint8_t samplerate;     //!&lt; Samplerate, in Hz</a>
<a name="ln101">  uint8_t resolution;     //!&lt; Resolution, in bits</a>
<a name="ln102">  uint8_t scale;          //!&lt; Scale, in relevant Si-unit</a>
<a name="ln103">  uint8_t dsp_function;   //!&lt; DSP function, one of @c RUUVI_DRIVER_SENSOR_DSP_*</a>
<a name="ln104">  uint8_t dsp_parameter;  //!&lt; Parameter to DSP functions</a>
<a name="ln105">  uint8_t mode;           //!&lt; Mode, RUUVI_DRIVER_SENSOR_SLEEP, _SINGLE, _CONTINOUS</a>
<a name="ln106">  uint8_t reserved0;      //!&lt; Reserved for future use</a>
<a name="ln107">  uint8_t reserved1;      //!&lt; Reserved for future use</a>
<a name="ln108">}</a>
<a name="ln109">ruuvi_driver_sensor_configuration_t;</a>
<a name="ln110"> </a>
<a name="ln111">/**</a>
<a name="ln112"> * @brief Type of bus sensor uses.</a>
<a name="ln113"> */</a>
<a name="ln114">typedef enum</a>
<a name="ln115">{</a>
<a name="ln116">  RUUVI_DRIVER_BUS_NONE = 0, //!&lt; No bus, internal to IC</a>
<a name="ln117">  RUUVI_DRIVER_BUS_SPI  = 1, //!&lt; SPI bus</a>
<a name="ln118">  RUUVI_DRIVER_BUS_I2C  = 2, //!&lt; I2C bus</a>
<a name="ln119">  RUUVI_DRIVER_BUS_UART = 3, //!&lt; UART bus</a>
<a name="ln120">  RUUVI_DRIVER_BUS_PDM  = 4, //!&lt; PDM bus</a>
<a name="ln121">  RUUVI_DRIVER_BUS_FAIL = 5  //!&lt; Test behaviour on invalid bus with this value.</a>
<a name="ln122">} ruuvi_driver_bus_t;</a>
<a name="ln123"> </a>
<a name="ln124">/**</a>
<a name="ln125"> * @brief Bitfield to describe related sensor data</a>
<a name="ln126"> */</a>
<a name="ln127">typedef struct{</a>
<a name="ln128">  unsigned int acceleration_x_g : 1; //!&lt; Acceleration along X-axis, gravities.</a>
<a name="ln129">  unsigned int acceleration_y_g : 1; //!&lt; Acceleration along Y-axis, gravities.</a>
<a name="ln130">  unsigned int acceleration_z_g : 1; //!&lt; Acceleration along Z-axis, gravities.</a>
<a name="ln131">  unsigned int co2_ppm : 1;          //!&lt; CO2, Parts per million.</a>
<a name="ln132">  unsigned int gyro_x_dps : 1;       //!&lt; Rotation along X-axis, degrees per second.</a>
<a name="ln133">  unsigned int gyro_y_dps : 1;       //!&lt; Rotation along Y-axis, degrees per second.</a>
<a name="ln134">  unsigned int gyro_z_dps : 1;       //!&lt; Rotation along Z-axis, degrees per second.</a>
<a name="ln135">  unsigned int humidity_rh :1;       //!&lt; Relative humidity, %.</a>
<a name="ln136">  unsigned int luminosity  :1;       //!&lt; Light level, dimensionless. Comparable only between identical devices.</a>
<a name="ln137">  unsigned int magnetometer_x_g : 1; //!&lt; Magnetic flux along X-axis, Gauss.</a>
<a name="ln138">  unsigned int magnetometer_y_g : 1; //!&lt; Magnetic flux along Y-axis, Gauss.</a>
<a name="ln139">  unsigned int magnetometer_z_g : 1; //!&lt; Magnetic flux along Z-axis, Gauss.</a>
<a name="ln140">  unsigned int pm_1_ugm3 : 1;        //!&lt; Ultra-fine particulate matter, microgram per m^3.</a>
<a name="ln141">  unsigned int pm_2_ugm3 : 1;        //!&lt; Fine particulate matter, microgram per m^3.</a>
<a name="ln142">  unsigned int pm_4_ugm3 : 1;        //!&lt; Medium particulate matter, microgram per m^3.</a>
<a name="ln143">  unsigned int pm_10_ugm3 : 1;       //!&lt; Coarse particulate matter, microgram per m^3.</a>
<a name="ln144">  unsigned int pressure_pa :1;       //!&lt; Pressure, pascals</a>
<a name="ln145">  unsigned int spl_dbz : 1;          //!&lt; Unweighted sound pressure level.</a>
<a name="ln146">  unsigned int temperature_c :1;     //!&lt; Temperature, celcius</a>
<a name="ln147">  unsigned int voc_ppm : 1;          //!&lt; Volatile organic compounds, parts per million.</a>
<a name="ln148">  unsigned int voltage_v : 1;        //!&lt; Voltage, volts. </a>
<a name="ln149">  unsigned int voltage_ratio : 1;    //!&lt; Voltage, ratio to maximum</a>
<a name="ln150">}ruuvi_driver_sensor_data_bitfield_t;</a>
<a name="ln151"> </a>
<a name="ln152">typedef union{</a>
<a name="ln153">  unsigned int bitfield;</a>
<a name="ln154">  ruuvi_driver_sensor_data_bitfield_t datas;</a>
<a name="ln155">}ruuvi_driver_sensor_data_fields_t;</a>
<a name="ln156"> </a>
<a name="ln157">/**</a>
<a name="ln158"> * @brief Generic sensor data struct. </a>
<a name="ln159"> */</a>
<a name="ln160">typedef struct ruuvi_driver_sensor_data_t</a>
<a name="ln161">{</a>
<a name="ln162">  uint64_t timestamp_ms;                    //!&lt; Timestamp of the event, @ref ruuvi_driver_sensor_timestamp_get.</a>
<a name="ln163">  ruuvi_driver_sensor_data_fields_t fields; //!&lt; Description of datafields which may be contained in this sample.</a>
<a name="ln164">  ruuvi_driver_sensor_data_fields_t valid;  //!&lt; Listing of valid data in this sample. </a>
<a name="ln165">  float* data;                              //!&lt; Data of sensor. </a>
<a name="ln166">} ruuvi_driver_sensor_data_t;</a>
<a name="ln167"> </a>
<a name="ln168">/** @brief Forward declare type definition of sensor structure */</a>
<a name="ln169">typedef struct ruuvi_driver_sensor_t ruuvi_driver_sensor_t; </a>
<a name="ln170"> </a>
<a name="ln171">/**</a>
<a name="ln172"> * @brief Initialize and uninitialize sensor.</a>
<a name="ln173"> * Init and uninit will setup sensor with function pointers.</a>
<a name="ln174"> * The sensor wil be initialized to lowest power state possible.</a>
<a name="ln175"> *</a>
<a name="ln176"> * @param[in,out] p_sensor pointer to sensor structure</a>
<a name="ln177"> * @param[in] bus bus to use, i.r. I2C or SPI</a>
<a name="ln178"> * @param[in] handle for the sensor, for example I2C address or SPI chip select pin</a>
<a name="ln179"> * @return @c RUUVI_DRIVER_SUCCESS on success</a>
<a name="ln180"> * @return @c RUUVI_DRIVER_ERROR_NULL if p_sensor is NULL</a>
<a name="ln181"> * @return @c RUUVI_DRIVER_ERROR_NOT_FOUND if there is no response from sensor or if ID of</a>
<a name="ln182"> *            a sensor read over bus does not match expected value</a>
<a name="ln183"> * @return @c RUUVI_DRIVER_ERROR_SELFTEST if sensor is found but it does not pass selftest</a>
<a name="ln184"> * @return @c RUUVI_DRIVER_ERROR_INVALID_STATE if trying to initialize sensor which </a>
<a name="ln185"> *            already has been initialized.</a>
<a name="ln186"> **/</a>
<a name="ln187">typedef ruuvi_driver_status_t (*ruuvi_driver_sensor_init_fp)(ruuvi_driver_sensor_t* const</a>
<a name="ln188">    p_sensor, const ruuvi_driver_bus_t bus, const uint8_t handle);</a>
<a name="ln189"> </a>
<a name="ln190">/**</a>
<a name="ln191"> *  @brief Setup a parameter of a sensor.</a>
<a name="ln192"> *  The function will modify the pointed data to the actual value which was written</a>
<a name="ln193"> *</a>
<a name="ln194"> *  @param[in,out] parameter value to write to sensor configuration. Actual value written to sensor as output</a>
<a name="ln195"> *  @return RUUVI_DRIVER_SUCCESS on success</a>
<a name="ln196"> *  @return RUUVI_DRIVER_ERROR_NULL if parameter is NULL</a>
<a name="ln197"> *  @return RUUVI_DRIVER_ERROR_NOT_SUPPORTED if sensor cannot support given parameter</a>
<a name="ln198"> *  @return RUUVI_DRIVER_ERROR_NOT_IMPLEMENTED if the sensor could support parameter, but it's not implemented in fw.</a>
<a name="ln199"> **/</a>
<a name="ln200">typedef ruuvi_driver_status_t (*ruuvi_driver_sensor_setup_fp)(uint8_t* parameter);</a>
<a name="ln201"> </a>
<a name="ln202">/**</a>
<a name="ln203"> * @brief Configure sensor digital signal processing.</a>
<a name="ln204"> * Takes DSP function and a DSP parameter as input, configured value or error code as output.</a>
<a name="ln205"> * Modifies input parameters to actual values written on the sensor.</a>
<a name="ln206"> * DSP functions are run on the sensor HW, not in the platform FW.</a>
<a name="ln207"> *</a>
<a name="ln208"> * @param[in,out] dsp_function. DSP function to run on sensor. Can be a combination of several functions.</a>
<a name="ln209"> * @param[in,out] dsp_parameter. Parameter to DSP function(s)</a>
<a name="ln210"> * @return RUUVI_DRIVER_SUCCESS on success</a>
<a name="ln211"> * @return RUUVI_DRIVER_ERROR_NULL if either parameter is NULL</a>
<a name="ln212"> * @return RUUVI_DRIVER_ERROR_NOT_SUPPORTED if sensor doesn't support given DSP</a>
<a name="ln213"> * @return RUUVI_DRIVER_ERROR_NOT_IMPLEMENTED if sensor supports given DSP, but</a>
<a name="ln214"> *         driver does not implement it</a>
<a name="ln215"> * @return RUUVI_DRIVER_ERROR_INVALID_PARAM if parameter is invalid for any reason.</a>
<a name="ln216"> **/</a>
<a name="ln217">typedef ruuvi_driver_status_t (*ruuvi_driver_sensor_dsp_fp)(uint8_t* dsp_function,</a>
<a name="ln218">    uint8_t* dsp_parameter);</a>
<a name="ln219"> </a>
<a name="ln220">/**</a>
<a name="ln221"> * @brief Read latest data from sensor registers</a>
<a name="ln222"> * Return latest data from sensor. Does not take a new sample, calling this function twice</a>
<a name="ln223"> * in a row returns same data. Configure sensor in a single-shot mode to take a new sample</a>
<a name="ln224"> * or leave sensor in a continuous mode to get updated data.</a>
<a name="ln225"> *</a>
<a name="ln226"> * @param [out] p_data Pointer to sensor data @ref ruuvi_driver_sensor_data_t .</a>
<a name="ln227"> * @return RUUVI_DRIVER_SUCCESS on success</a>
<a name="ln228"> * @return RUUVI_DRIVER_ERROR_NULL if p_data is @c NULL.</a>
<a name="ln229"> *</a>
<a name="ln230"> * @warning if sensor data is not valid for any reason, data is populated with </a>
<a name="ln231"> *          @c RUUVI_DRIVER_FLOAT_INVALID.</a>
<a name="ln232"> */</a>
<a name="ln233">typedef ruuvi_driver_status_t (*ruuvi_driver_sensor_data_fp)(ruuvi_driver_sensor_data_t* const p_data);</a>
<a name="ln234"> </a>
<a name="ln235">/**</a>
<a name="ln236"> * @brief Convenience function to write/read entire configuration in one call.</a>
<a name="ln237"> * Modifies input parameters to actual values written on the sensor.</a>
<a name="ln238"> *</a>
<a name="ln239"> * @param[in] p_sensor sensor to configure</a>
<a name="ln240"> * @param[in,out] p_configuration Input: desired configuration. Output: </a>
<a name="ln241"> *                configuration written to sensot.</a>
<a name="ln242"> **/</a>
<a name="ln243">typedef ruuvi_driver_status_t (*ruuvi_driver_configuration_fp)(</a>
<a name="ln244">  const ruuvi_driver_sensor_t* const p_sensor,</a>
<a name="ln245">  ruuvi_driver_sensor_configuration_t* const p_configuration);</a>
<a name="ln246"> </a>
<a name="ln247">/**</a>
<a name="ln248">* @brief Read First-in-first-out (FIFO) buffer</a>
<a name="ln249">* Reads up to num_elements data points from FIFO and populates pointer data with them</a>
<a name="ln250">*</a>
<a name="ln251">* @param[in, out] num_elements Input: number of elements in data. </a>
<a name="ln252">                               Output: Number of elements placed in data</a>
<a name="ln253">* @param[out] data array of ruuvi_interface_acceleration_data_t with num_elements slots.</a>
<a name="ln254">* @return RUUVI_DRIVER_SUCCESS on success</a>
<a name="ln255">* @return RUUVI_DRIVER_ERROR_NULL if either parameter is NULL</a>
<a name="ln256">* @return RUUVI_DRIVER_ERROR_INVALID_STATE if FIFO is not in use</a>
<a name="ln257">* @return error code from stack on error.</a>
<a name="ln258">*/</a>
<a name="ln259">typedef ruuvi_driver_status_t (*ruuvi_driver_sensor_fifo_read_fp)(size_t* num_elements,</a>
<a name="ln260">    ruuvi_driver_sensor_data_t* const data);</a>
<a name="ln261"> </a>
<a name="ln262">/**</a>
<a name="ln263">* @brief Enable FIFO or FIFO interrupt full interrupt on sensor.</a>
<a name="ln264">* FIFO interrupt Triggers as ACTIVE HIGH interrupt once FIFO is filled. </a>
<a name="ln265">* It is responsibility of application to know the routing of GPIO pins and</a>
<a name="ln266">* configure the GPIO to register interrupts.</a>
<a name="ln267">*</a>
<a name="ln268">* @param[in] enable True to enable interrupt, false to disable interrupt</a>
<a name="ln269">* @return RUUVI_DRIVER_SUCCESS on success, error code from stack otherwise.</a>
<a name="ln270">**/</a>
<a name="ln271">typedef ruuvi_driver_status_t (*ruuvi_driver_sensor_fifo_enable_fp)(const bool enable);</a>
<a name="ln272"> </a>
<a name="ln273">/**</a>
<a name="ln274">* @brief Enable level interrupt on sensor.</a>
<a name="ln275">* Triggers as ACTIVE HIGH interrupt while detected data is above threshold.</a>
<a name="ln276">* Trigger is symmetric, i.e. thershold is valid for above positive or below negative </a>
<a name="ln277">* of given value.</a>
<a name="ln278">* On accelerometer data is high-passed to filter out gravity.</a>
<a name="ln279">* Axes are examined individually, compound data won't trigger the interrupt.</a>
<a name="ln280">* It is responsibility of application to know the GPIO routing and register</a>
<a name="ln281">* GPIO interrupts. </a>
<a name="ln282">*</a>
<a name="ln283">* @param[in] enable  True to enable interrupt, false to disable interrupt</a>
<a name="ln284">* @param[in,out] limit_g: Input: Desired acceleration to trigger the interrupt.</a>
<a name="ln285">*                         Is considered as &quot;at least&quot;, the acceleration is rounded up to </a>
<a name="ln286">*                         next value.</a>
<a name="ln287">*                         Output: written with value that was set to interrupt</a>
<a name="ln288">* @return RUUVI_DRIVER_SUCCESS on success</a>
<a name="ln289">* @return RUUVI_DRIVER_INVALID_STATE if data limit is higher than maximum scale</a>
<a name="ln290">* @return error code from stack on error.</a>
<a name="ln291">*</a>
<a name="ln292">*/</a>
<a name="ln293">typedef ruuvi_driver_status_t (*ruuvi_driver_sensor_level_interrupt_use_fp)(const bool enable,</a>
<a name="ln294">    float* limit_g);</a>
<a name="ln295"> </a>
<a name="ln296">/**</a>
<a name="ln297"> * @brief Return number of milliseconds since the start of RTC.</a>
<a name="ln298"> *</a>
<a name="ln299"> * @return milliseconds since start of RTC.</a>
<a name="ln300"> * @return RUUVI_DRIVER_UINT64T_INVALID if RTC is not running</a>
<a name="ln301"> */</a>
<a name="ln302">typedef uint64_t (*ruuvi_driver_sensor_timestamp_fp)(void);</a>
<a name="ln303"> </a>
<a name="ln304">/**</a>
<a name="ln305"> * @brief Interface to sensor.</a>
<a name="ln306"> * Some sensors can implement additional functions.</a>
<a name="ln307"> * The additional functions are defined in the interface of the sensor.</a>
<a name="ln308"> */</a>
<a name="ln309">typedef struct ruuvi_driver_sensor_t</a>
<a name="ln310">{</a>
<a name="ln311">  /** @brief sensor human-readable name. Should be at most 8 bytes long. */</a>
<a name="ln312">  const char* name;</a>
<a name="ln313">  /** @brief Description of data fields the sensor is able to provide. */</a>
<a name="ln314">  ruuvi_driver_sensor_data_fields_t provides;</a>
<a name="ln315">  /** @brief @ref ruuvi_driver_sensor_init_fp */</a>
<a name="ln316">  ruuvi_driver_sensor_init_fp   init;  </a>
<a name="ln317">  /** @brief @ref ruuvi_driver_sensor_init_fp */            </a>
<a name="ln318">  ruuvi_driver_sensor_init_fp   uninit;            </a>
<a name="ln319">  /** @brief @ref ruuvi_driver_sensor_setup_fp */</a>
<a name="ln320">  ruuvi_driver_sensor_setup_fp samplerate_set; </a>
<a name="ln321">  /** @brief @ref ruuvi_driver_sensor_setup_fp */</a>
<a name="ln322">  ruuvi_driver_sensor_setup_fp samplerate_get;</a>
<a name="ln323">  /** @brief @ref ruuvi_driver_sensor_setup_fp */</a>
<a name="ln324">  ruuvi_driver_sensor_setup_fp resolution_set;</a>
<a name="ln325">  /** @brief @ref ruuvi_driver_sensor_setup_fp */</a>
<a name="ln326">  ruuvi_driver_sensor_setup_fp resolution_get;</a>
<a name="ln327">  /** @brief @ref ruuvi_driver_sensor_setup_fp */</a>
<a name="ln328">  ruuvi_driver_sensor_setup_fp scale_set;</a>
<a name="ln329">  /** @brief @ref ruuvi_driver_sensor_setup_fp */</a>
<a name="ln330">  ruuvi_driver_sensor_setup_fp scale_get;</a>
<a name="ln331">  /** @brief @ref ruuvi_driver_sensor_setup_fp */</a>
<a name="ln332">  ruuvi_driver_sensor_setup_fp mode_set;</a>
<a name="ln333">  /** @brief @ref ruuvi_driver_sensor_setup_fp */</a>
<a name="ln334">  ruuvi_driver_sensor_setup_fp mode_get;</a>
<a name="ln335">  /** @brief @ref ruuvi_driver_sensor_dsp_fp */</a>
<a name="ln336">  ruuvi_driver_sensor_dsp_fp   dsp_set;</a>
<a name="ln337">  /** @brief @ref ruuvi_driver_sensor_dsp_fp */</a>
<a name="ln338">  ruuvi_driver_sensor_dsp_fp   dsp_get;</a>
<a name="ln339">  /** @brief @ref ruuvi_driver_configuration_fp */</a>
<a name="ln340">  ruuvi_driver_configuration_fp configuration_set;</a>
<a name="ln341">  /** @brief @ref ruuvi_driver_configuration_fp */</a>
<a name="ln342">  ruuvi_driver_configuration_fp configuration_get;</a>
<a name="ln343">  /** @brief @ref ruuvi_driver_sensor_data_fp */</a>
<a name="ln344">  ruuvi_driver_sensor_data_fp   data_get;        </a>
<a name="ln345">  /** @brief @速ef ruuvi_driver_sensor_fifo_enable_fp */</a>
<a name="ln346">  ruuvi_driver_sensor_fifo_enable_fp fifo_enable;</a>
<a name="ln347">  /** @brief @速ef ruuvi_driver_sensor_level_interrupt_use_fp */</a>
<a name="ln348">  ruuvi_driver_sensor_fifo_enable_fp fifo_interrupt_enable;</a>
<a name="ln349">  /** @brief @速ef ruuvi_driver_sensor_level_interrupt_use_fp */</a>
<a name="ln350">  ruuvi_driver_sensor_fifo_read_fp   fifo_read;</a>
<a name="ln351">  /** @brief @速ef ruuvi_driver_sensor_level_interrupt_use_fp */</a>
<a name="ln352">  ruuvi_driver_sensor_level_interrupt_use_fp level_interrupt_set;</a>
<a name="ln353">} ruuvi_driver_sensor_t;</a>
<a name="ln354"> </a>
<a name="ln355">/**</a>
<a name="ln356"> * @brief implementation of ref ruuvi_driver_configuration_fp</a>
<a name="ln357"> */</a>
<a name="ln358">ruuvi_driver_status_t ruuvi_driver_sensor_configuration_set(const ruuvi_driver_sensor_t*</a>
<a name="ln359">    sensor, ruuvi_driver_sensor_configuration_t* config);</a>
<a name="ln360"> </a>
<a name="ln361">/**</a>
<a name="ln362"> * @brief implementation of ref ruuvi_driver_configuration_fp</a>
<a name="ln363"> */</a>
<a name="ln364">ruuvi_driver_status_t ruuvi_driver_sensor_configuration_get(const ruuvi_driver_sensor_t*</a>
<a name="ln365">    sensor, ruuvi_driver_sensor_configuration_t* config);</a>
<a name="ln366"> </a>
<a name="ln367">/**</a>
<a name="ln368"> * @brief Setup timestamping</a>
<a name="ln369"> * Set to @c NULL to disable timestamps.</a>
<a name="ln370"> *</a>
<a name="ln371"> * @param[in] timestamp_fp Function pointer to @ref ruuvi_driver_sensor_timestamp_fp implementation</a>
<a name="ln372"> * @return RUUVI_DRIVER_SUCCESS</a>
<a name="ln373"> */</a>
<a name="ln374">ruuvi_driver_status_t ruuvi_driver_sensor_timestamp_function_set(</a>
<a name="ln375">  const ruuvi_driver_sensor_timestamp_fp  timestamp_fp);</a>
<a name="ln376"> </a>
<a name="ln377">/**</a>
<a name="ln378"> * @brief Calls the timestamp function and returns its value.</a>
<a name="ln379"> * @return milliseconds since the start of RTC</a>
<a name="ln380"> * @return RUUVI_DRIVER_UINT64_INVALID if timestamp function is NULL</a>
<a name="ln381"> */</a>
<a name="ln382">uint64_t ruuvi_driver_sensor_timestamp_get(void);</a>
<a name="ln383"> </a>
<a name="ln384">/**</a>
<a name="ln385"> * @brief Initialize sensor struct with non-null pointers which return RUUVI_DRIVER_ERROR_NOT_INITIALIZED</a>
<a name="ln386"> *</a>
<a name="ln387"> * @param[out] p_sensor pointer to sensor struct to initialize.</a>
<a name="ln388"> */</a>
<a name="ln389">void ruuvi_driver_sensor_initialize(ruuvi_driver_sensor_t* const p_sensor);</a>
<a name="ln390"> </a>
<a name="ln391">/**</a>
<a name="ln392"> * @brief Mark sensor as uninitialized by calling the generic initialization. </a>
<a name="ln393"> *</a>
<a name="ln394"> * @param[out] p_sensor pointer to sensor struct to uninitialize.</a>
<a name="ln395"> */</a>
<a name="ln396">void ruuvi_driver_sensor_uninitialize(ruuvi_driver_sensor_t* const p_sensor);</a>
<a name="ln397"> </a>
<a name="ln398">/**</a>
<a name="ln399"> * @brief Check if given sensor structure is already initialized. </a>
<a name="ln400"> *</a>
<a name="ln401"> * @param[in] sensor Sensor interface to check.</a>
<a name="ln402"> * @return true if structure is initialized, false otherwise.</a>
<a name="ln403"> */</a>
<a name="ln404">bool ruuvi_driver_sensor_is_init(const ruuvi_driver_sensor_t* const sensor);</a>
<a name="ln405"> </a>
<a name="ln406">/** </a>
<a name="ln407"> * @brief Populate given target data with data provided by sensor as requested. </a>
<a name="ln408"> *</a>
<a name="ln409"> * This function looks up the appropriate assigments on each data field in given target</a>
<a name="ln410"> * and populates it with provided data if caller requested the field to be populated.</a>
<a name="ln411"> * Populated fields are marked as valid. </a>
<a name="ln412"> *</a>
<a name="ln413"> * @param[out] target Data to be populated.</a>
<a name="ln414"> * @param[in]  provided Data provided by sensor.</a>
<a name="ln415"> * @param[in]  requested Fields to be filled if possible. </a>
<a name="ln416"> */</a>
<a name="ln417">void ruuvi_driver_sensor_data_populate(ruuvi_driver_sensor_data_t* const target,</a>
<a name="ln418">                                       const ruuvi_driver_sensor_data_t* const provided,</a>
<a name="ln419">                                       const ruuvi_driver_sensor_data_fields_t requested);</a>
<a name="ln420"> </a>
<a name="ln421">/** </a>
<a name="ln422"> * @brief Parse data from provided struct</a>
<a name="ln423"> *</a>
<a name="ln424"> * This function looks up the appropriate assigments on each data field in given target</a>
<a name="ln425"> * and populates it with provided data if caller requested the field to be populated.</a>
<a name="ln426"> *</a>
<a name="ln427"> * @param[out] target Data to be populated.</a>
<a name="ln428"> * @param[in]  provided Data provided by sensor.</a>
<a name="ln429"> * @param[in]  requested Data to be parsed if possible</a>
<a name="ln430"> * @return     sensor value if found, RUUVI_DRIVER_FLOAT_INVALID if the provided data didn't have a valid value. </a>
<a name="ln431"> */</a>
<a name="ln432">float ruuvi_driver_sensor_data_parse(const ruuvi_driver_sensor_data_t* const provided,</a>
<a name="ln433">                                     const ruuvi_driver_sensor_data_fields_t requested);</a>
<a name="ln434"> </a>
<a name="ln435">/** </a>
<a name="ln436"> * @brief count number of floats required for this data structure</a>
<a name="ln437"> *</a>
<a name="ln438"> * This function looks up the appropriate assigments on each data field in given target</a>
<a name="ln439"> * and populates it with provided data if caller requested the field to be populated.</a>
<a name="ln440"> *</a>
<a name="ln441"> * @param[in]  target Structure to count number of fields from.</a>
<a name="ln442"> * @return     Number of floats required to store the sensor data. </a>
<a name="ln443"> */</a>
<a name="ln444">uint8_t ruuvi_driver_sensor_data_fieldcount(const ruuvi_driver_sensor_data_t* const target);</a>
<a name="ln445"> </a>
<a name="ln446">/** </a>
<a name="ln447"> * @brief Set a desired value to target data.</a>
<a name="ln448"> *</a>
<a name="ln449"> * This function looks up the appropriate assigments on each data field in given target</a>
<a name="ln450"> * and populates it with provided data. DOes nothing if there is no appropriate slot</a>
<a name="ln451"> * in target data.</a>
<a name="ln452"> *</a>
<a name="ln453"> * @param[in]  target </a>
<a name="ln454"> * @param[in]  field  Quantity to set, exactly one must be set to true. </a>
<a name="ln455"> * @param[in]  value  Value of quantity</a>
<a name="ln456"> */</a>
<a name="ln457">void ruuvi_driver_sensor_data_set(ruuvi_driver_sensor_data_t* const target,</a>
<a name="ln458">                                  const ruuvi_driver_sensor_data_fields_t field,</a>
<a name="ln459">                                  const float value);</a>
<a name="ln460">/*@}*/</a>
<a name="ln461">#endif</a>

</code></pre>
<div class="balloon" rel="152"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2514/" target="_blank">V2514</a> Unions should not be used.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
