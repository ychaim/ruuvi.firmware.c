
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>main.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * @defgroup main Program main</a>
<a name="ln3"> *</a>
<a name="ln4"> */</a>
<a name="ln5">/*@}*/</a>
<a name="ln6">/**</a>
<a name="ln7"> * @addtogroup main</a>
<a name="ln8"> */</a>
<a name="ln9">/*@{*/</a>
<a name="ln10">/**</a>
<a name="ln11"> * @file main.c</a>
<a name="ln12"> * @author Otso Jousimaa &lt;otso@ojousima.net&gt;</a>
<a name="ln13"> * @date 2019-12-26</a>
<a name="ln14"> * @copyright Ruuvi Innovations Ltd, license BSD-3-Clause.</a>
<a name="ln15"> */</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;application_config.h&quot;</a>
<a name="ln18">#include &quot;ruuvi_interface_communication_radio.h&quot;</a>
<a name="ln19">#include &quot;ruuvi_interface_log.h&quot;</a>
<a name="ln20">#include &quot;ruuvi_interface_rtc.h&quot;</a>
<a name="ln21">#include &quot;ruuvi_interface_scheduler.h&quot;</a>
<a name="ln22">#include &quot;ruuvi_interface_watchdog.h&quot;</a>
<a name="ln23">#include &quot;ruuvi_interface_yield.h&quot;</a>
<a name="ln24">#include &quot;ruuvi_boards.h&quot;</a>
<a name="ln25">#include &quot;task_acceleration.h&quot;</a>
<a name="ln26">#include &quot;task_adc.h&quot;</a>
<a name="ln27">#include &quot;task_advertisement.h&quot;</a>
<a name="ln28">#include &quot;task_button.h&quot;</a>
<a name="ln29">#include &quot;task_environmental.h&quot;</a>
<a name="ln30">#include &quot;task_flash.h&quot;</a>
<a name="ln31">#include &quot;task_gatt.h&quot;</a>
<a name="ln32">#include &quot;task_gpio.h&quot;</a>
<a name="ln33">#include &quot;task_led.h&quot;</a>
<a name="ln34">#include &quot;task_i2c.h&quot;</a>
<a name="ln35">#include &quot;task_nfc.h&quot;</a>
<a name="ln36">#include &quot;task_power.h&quot;</a>
<a name="ln37">#include &quot;task_rtc.h&quot;</a>
<a name="ln38">#include &quot;task_scheduler.h&quot;</a>
<a name="ln39">#include &quot;task_sensor.h&quot;</a>
<a name="ln40">#include &quot;task_spi.h&quot;</a>
<a name="ln41">#include &quot;task_timer.h&quot;</a>
<a name="ln42">#include &quot;test_sensor.h&quot;</a>
<a name="ln43">#include &quot;test_acceleration.h&quot;</a>
<a name="ln44">#include &quot;test_adc.h&quot;</a>
<a name="ln45">#include &quot;test_environmental.h&quot;</a>
<a name="ln46">#include &quot;test_library.h&quot;</a>
<a name="ln47">#include &quot;main.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49">#include &lt;stdio.h&gt;</a>
<a name="ln50">#include &lt;string.h&gt;</a>
<a name="ln51"> </a>
<a name="ln52">// Constants #defined at main.h for Ceedling.ÃŸ</a>
<a name="ln53"> </a>
<a name="ln54">static inline void LOG (const char * const msg)</a>
<a name="ln55">{</a>
<a name="ln56">    ruuvi_interface_log (MAIN_LOG_LEVEL, msg);</a>
<a name="ln57">}</a>
<a name="ln58"> </a>
<a name="ln59">#if 0</a>
<a name="ln60">static inline void LOGD (const char * const msg)</a>
<a name="ln61">{</a>
<a name="ln62">    ruuvi_interface_log (RUUVI_INTERFACE_LOG_DEBUG, msg);</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65">static inline void LOGHEX (const uint8_t * const msg, const size_t len)</a>
<a name="ln66">{</a>
<a name="ln67">    ruuvi_interface_log_hex (MAIN_LOG_LEVEL, msg, len);</a>
<a name="ln68">}</a>
<a name="ln69">#endif</a>
<a name="ln70"> </a>
<a name="ln71">/** Run tests which rely only on MCU.</a>
<a name="ln72"> *  These tests require relevant peripherals being uninitialized</a>
<a name="ln73"> *  before tests and leave the peripherals uninitialized.</a>
<a name="ln74"> *  Production firmware should not run these tests.</a>
<a name="ln75"> *</a>
<a name="ln76"> *  @Note These are integration tests run on actual hardware, Ceedling</a>
<a name="ln77"> *  should not run this function.</a>
<a name="ln78"> */</a>
<a name="ln79">static void run_mcu_tests (void)</a>
<a name="ln80">{</a>
<a name="ln81">#if RUUVI_RUN_TESTS</a>
<a name="ln82">    LOG (&quot;'mcu_tests':{\r\n&quot;);</a>
<a name="ln83">    ruuvi_driver_sensor_timestamp_function_set (ruuvi_interface_rtc_millis);</a>
<a name="ln84">    ruuvi_interface_rtc_init();</a>
<a name="ln85">    test_adc_run();</a>
<a name="ln86">    test_library_run();</a>
<a name="ln87">    // Delay to avoid locking RTC</a>
<a name="ln88">    ruuvi_interface_delay_ms (BOOT_DELAY_MS);</a>
<a name="ln89">    ruuvi_interface_rtc_uninit();</a>
<a name="ln90">    LOG (&quot;}\r\n&quot;);</a>
<a name="ln91">#endif</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94">/**</a>
<a name="ln95"> *  @brief Synchronize ADC measurement to radio.</a>
<a name="ln96"> *  This is common to all radio modules, i.e.</a>
<a name="ln97"> *  the callback gets called for every radio action.</a>
<a name="ln98"> *</a>
<a name="ln99"> *  @param[in] evt Type of radio event</a>
<a name="ln100"> */</a>
<a name="ln101">#ifndef CEEDLING</a>
<a name="ln102">static</a>
<a name="ln103">#endif</a>
<a name="ln104">void on_radio (const ruuvi_interface_communication_radio_activity_evt_t evt)</a>
<a name="ln105">{</a>
<a name="ln106">    static bool triggered = false;</a>
<a name="ln107">    static uint64_t last_sample = 0;</a>
<a name="ln108">    ruuvi_driver_status_t err_code = RUUVI_DRIVER_SUCCESS;</a>
<a name="ln109"> </a>
<a name="ln110">    if ( (RUUVI_INTERFACE_COMMUNICATION_RADIO_BEFORE == evt) &amp;&amp;</a>
<a name="ln111">            ( (ruuvi_interface_rtc_millis() - last_sample) &gt;</a>
<a name="ln112">              APPLICATION_ADC_SAMPLE_INTERVAL_MS))</a>
<a name="ln113">    {</a>
<a name="ln114">        err_code |= task_adc_vdd_prepare();</a>
<a name="ln115">        triggered = (RUUVI_DRIVER_SUCCESS == err_code);</a>
<a name="ln116">    }</a>
<a name="ln117"> </a>
<a name="ln118">    if ( (RUUVI_INTERFACE_COMMUNICATION_RADIO_AFTER == evt) &amp;&amp;</a>
<a name="ln119">            triggered)</a>
<a name="ln120">    {</a>
<a name="ln121">        err_code |= task_adc_vdd_sample();</a>
<a name="ln122">        triggered = false;</a>
<a name="ln123"> </a>
<a name="ln124">        if (RUUVI_DRIVER_SUCCESS == err_code)</a>
<a name="ln125">        {</a>
<a name="ln126">            last_sample = ruuvi_interface_rtc_millis();</a>
<a name="ln127">        }</a>
<a name="ln128">    }</a>
<a name="ln129"> </a>
<a name="ln130">    RUUVI_DRIVER_ERROR_CHECK (err_code, ~RUUVI_DRIVER_ERROR_FATAL);</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">/*</a>
<a name="ln134"> * @brief Initialize MCU peripherals.</a>
<a name="ln135"> *</a>
<a name="ln136"> * The watchdog is initialized first.</a>
<a name="ln137"> * After watchdog, GPIO, including interrupts, are initialized.</a>
<a name="ln138"> * Leds are initialized by activating led pins as high-drive outputs and inactive.</a>
<a name="ln139"> * SPI is initialized by reserving a peripheral and configuring I/O modes.</a>
<a name="ln140"> * I2C is initialized by reserving a peripheral and configuring I/O modes.</a>
<a name="ln141"> *</a>
<a name="ln142"> * Timer and RTC are initialized by reserving the peripherals.</a>
<a name="ln143"> * Scheduler is SW-only, initialization reserves buffer for task queue.</a>
<a name="ln144"> *</a>
<a name="ln145"> * Once timer is initialized, sleep is configured to go to deepest possible sleep mode</a>
<a name="ln146"> * and wake on timer on instead of busylooping. This causes imprecision to ms delays.</a>
<a name="ln147"> *</a>
<a name="ln148"> * If DC/DC converter is installed on board, it is initialized.</a>
<a name="ln149"> *</a>
<a name="ln150"> * Flash is initialized by checking if the filesystem can be allocated. In some cases</a>
<a name="ln151"> * such as changing allocated flash filesystem size the filesystem area is erased</a>
<a name="ln152"> * and program reboots.</a>
<a name="ln153"> *</a>
<a name="ln154"> * ADC is not reserved at this stage, but VDD is sampled.</a>
<a name="ln155"> *</a>
<a name="ln156"> */</a>
<a name="ln157">#ifndef CEEDLING</a>
<a name="ln158">static</a>
<a name="ln159">#endif</a>
<a name="ln160">void init_mcu (void)</a>
<a name="ln161">{</a>
<a name="ln162">    // Init watchdog</a>
<a name="ln163">    ruuvi_interface_watchdog_init (APPLICATION_WATCHDOG_INTERVAL_MS);</a>
<a name="ln164">    // Init yield</a>
<a name="ln165">    ruuvi_driver_status_t status = ruuvi_interface_yield_init();</a>
<a name="ln166">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln167">    // Init GPIO</a>
<a name="ln168">    status = task_gpio_init();</a>
<a name="ln169">    // Initialize LED gpio pins</a>
<a name="ln170">    status |= task_led_init();</a>
<a name="ln171">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln172">    // Initialize SPI, I2C</a>
<a name="ln173">    status = task_spi_init();</a>
<a name="ln174">    status |= task_i2c_init();</a>
<a name="ln175">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln176">    // Initialize RTC, timer and scheduler. Enable low-power sleep.</a>
<a name="ln177">    // Dummy implementation of RTC requires timer.</a>
<a name="ln178">    status = task_timer_init();</a>
<a name="ln179">    status |= task_rtc_init();</a>
<a name="ln180">    status |= task_scheduler_init();</a>
<a name="ln181">    // Low power yield goes to deep sleep and wakes the CPU with a timer,</a>
<a name="ln182">    // hence timer is required.</a>
<a name="ln183">    status |= ruuvi_interface_yield_low_power_enable (true);</a>
<a name="ln184">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln185">    // Initialize power perihperals,</a>
<a name="ln186">    status |= task_power_dcdc_init();</a>
<a name="ln187">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln188">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln189">    // Initialize flash</a>
<a name="ln190">    status = task_flash_init();</a>
<a name="ln191">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln192">    // Sample VDD</a>
<a name="ln193">    status |= task_adc_vdd_prepare();</a>
<a name="ln194">    status |= task_adc_vdd_sample();</a>
<a name="ln195">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">/*</a>
<a name="ln199"> * @brief Run series of selftests which verify the underlying drivers, libraries etc.</a>
<a name="ln200"> *</a>
<a name="ln201"> * @note  These are integration tests, Ceedling should not run these.</a>
<a name="ln202"> */</a>
<a name="ln203">static void run_sensor_tests (void)</a>
<a name="ln204">{</a>
<a name="ln205">#if RUUVI_RUN_TESTS</a>
<a name="ln206">    // Tests will initialize and uninitialize the sensors,</a>
<a name="ln207">    // run this before using them in application</a>
<a name="ln208">    ruuvi_interface_log (RUUVI_INTERFACE_LOG_INFO,</a>
<a name="ln209">                         &quot;Running extended self-tests, this might take a while\r\n&quot;);</a>
<a name="ln210">    ruuvi_interface_watchdog_feed();</a>
<a name="ln211">    test_acceleration_run();</a>
<a name="ln212">    ruuvi_interface_watchdog_feed();</a>
<a name="ln213">    test_environmental_run();</a>
<a name="ln214">    ruuvi_interface_watchdog_feed();</a>
<a name="ln215">    // Print unit test status, activate tests by building in DEBUG configuration under SES</a>
<a name="ln216">    size_t tests_run, tests_passed;</a>
<a name="ln217">    test_sensor_status (&amp;tests_run, &amp;tests_passed);</a>
<a name="ln218">    char message[LOG_BUF_SIZE] = {0};</a>
<a name="ln219">    snprintf (message, sizeof (message), &quot;Tests ran: %u, passed: %u\r\n&quot;, tests_run,</a>
<a name="ln220">              tests_passed);</a>
<a name="ln221">    ruuvi_interface_log (RUUVI_INTERFACE_LOG_INFO, message);</a>
<a name="ln222">    // Init watchdog after tests. Normally init at the start of the program</a>
<a name="ln223">#endif</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">static void init_sensors (void)</a>
<a name="ln227">{</a>
<a name="ln228">    ruuvi_driver_status_t status = RUUVI_DRIVER_SUCCESS;</a>
<a name="ln229">    // Initialize environmental- nRF52 will return ERROR NOT SUPPORTED on RuuviTag basic</a>
<a name="ln230">    // if DSP was configured, log warning</a>
<a name="ln231">    status = task_environmental_init();</a>
<a name="ln232">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_ERROR_NOT_SUPPORTED);</a>
<a name="ln233">    // Allow NOT FOUND in case we're running on basic model</a>
<a name="ln234">    status = task_acceleration_init();</a>
<a name="ln235">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_ERROR_NOT_FOUND);</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">#if APPLICATION_COMMUNICATION_GATT_ENABLED</a>
<a name="ln239">/** @brief Handle NUS connection event.</a>
<a name="ln240"> *</a>
<a name="ln241"> * Configures application to start sending the data via GATT instead of</a>
<a name="ln242"> * BLE advertisements.</a>
<a name="ln243"> *</a>
<a name="ln244"> * @param data Unused, contains event data which is NULL.</a>
<a name="ln245"> * @param data_len Unused, always 0.</a>
<a name="ln246"> */</a>
<a name="ln247">#ifndef CEEDLING</a>
<a name="ln248">static</a>
<a name="ln249">#endif</a>
<a name="ln250">void on_gatt_connected_isr (void * data, size_t data_len)</a>
<a name="ln251">{</a>
<a name="ln252">    LOG (&quot;GATT Connected ISR\r\n&quot;);</a>
<a name="ln253">    ruuvi_driver_status_t status = RUUVI_DRIVER_SUCCESS;</a>
<a name="ln254">    status |= task_advertisement_stop();</a>
<a name="ln255">    status |= task_communication_heartbeat_configure (</a>
<a name="ln256">                  APPLICATION_GATT_HEARTBEAT_INTERVAL_MS,</a>
<a name="ln257">                  GATT_HEARTBEAT_SIZE,</a>
<a name="ln258">                  &amp;task_sensor_encode_to_5,</a>
<a name="ln259">                  &amp;task_gatt_send_asynchronous);</a>
<a name="ln260">    RUUVI_DRIVER_ERROR_CHECK (status, ~RUUVI_DRIVER_ERROR_FATAL);</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">/** @brief Handle NUS disconnection event.</a>
<a name="ln264"> *</a>
<a name="ln265"> * Configures application to start data in  BLE advertisements.</a>
<a name="ln266"> *</a>
<a name="ln267"> * @param data Unused, contains event data which is NULL.</a>
<a name="ln268"> * @param data_len Unused, always 0.</a>
<a name="ln269"> */</a>
<a name="ln270">#ifndef CEEDLING</a>
<a name="ln271">static</a>
<a name="ln272">#endif</a>
<a name="ln273">void on_gatt_disconnected_isr (void * data, size_t data_len)</a>
<a name="ln274">{</a>
<a name="ln275">    LOG (&quot;GATT Disconnected ISR\r\n&quot;);</a>
<a name="ln276">    ruuvi_driver_status_t status = RUUVI_DRIVER_SUCCESS;</a>
<a name="ln277">    status |= task_communication_heartbeat_configure (</a>
<a name="ln278">                  APPLICATION_ADVERTISEMENT_UPDATE_INTERVAL_MS,</a>
<a name="ln279">                  RUUVI_INTERFACE_COMMUNICATION_MESSAGE_MAX_LENGTH,</a>
<a name="ln280">                  &amp;task_sensor_encode_to_5,</a>
<a name="ln281">                  &amp;task_advertisement_send_data);</a>
<a name="ln282">    status |= task_advertisement_start();</a>
<a name="ln283">    RUUVI_DRIVER_ERROR_CHECK (status, ~RUUVI_DRIVER_ERROR_FATAL);</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">/** @brief Handle incoming NUS data outside interrupt context.</a>
<a name="ln287"> *</a>
<a name="ln288"> * Pauses heartbeat transmissions and passes the data along with</a>
<a name="ln289"> * reply function pointer to task communication.</a>
<a name="ln290"> *</a>
<a name="ln291"> * @param data Unused, contains event data which is NULL.</a>
<a name="ln292"> * @param data_len Unused, always 0.</a>
<a name="ln293"> */</a>
<a name="ln294">#ifndef CEEDLING</a>
<a name="ln295">static</a>
<a name="ln296">#endif</a>
<a name="ln297">void process_gatt_command (void * p_event_data, uint16_t event_size)</a>
<a name="ln298">{</a>
<a name="ln299">    ruuvi_driver_status_t err_code = RUUVI_DRIVER_SUCCESS;</a>
<a name="ln300"> </a>
<a name="ln301">    if ( (NULL != p_event_data)</a>
<a name="ln302">            &amp;&amp; (RUUVI_INTERFACE_COMMUNICATION_MESSAGE_MAX_LENGTH &gt;= event_size))</a>
<a name="ln303">    {</a>
<a name="ln304">        // Pause heartbeats for processing</a>
<a name="ln305">        task_communication_heartbeat_configure (0,</a>
<a name="ln306">                                                GATT_HEARTBEAT_SIZE,</a>
<a name="ln307">                                                task_sensor_encode_to_5,</a>
<a name="ln308">                                                task_gatt_send_asynchronous);</a>
<a name="ln309">        ruuvi_interface_communication_message_t msg = {0};</a>
<a name="ln310">        memcpy (msg.data, p_event_data, event_size);</a>
<a name="ln311">        msg.data_length = event_size;</a>
<a name="ln312">        err_code |= task_communication_on_data (&amp;msg,</a>
<a name="ln313">                                                task_gatt_send_asynchronous);</a>
<a name="ln314">        // Restore heartbeats</a>
<a name="ln315">        task_communication_heartbeat_configure (APPLICATION_GATT_HEARTBEAT_INTERVAL_MS,</a>
<a name="ln316">                                                GATT_HEARTBEAT_SIZE,</a>
<a name="ln317">                                                task_sensor_encode_to_5, task_gatt_send_asynchronous);</a>
<a name="ln318">    }</a>
<a name="ln319">    else</a>
<a name="ln320">    {</a>
<a name="ln321">        err_code |= RUUVI_DRIVER_ERROR_DATA_SIZE;</a>
<a name="ln322">    }</a>
<a name="ln323"> </a>
<a name="ln324">    RUUVI_DRIVER_ERROR_CHECK (err_code, ~RUUVI_DRIVER_ERROR_FATAL);</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327"> </a>
<a name="ln328">/** @brief Handle incoming NUS data inside interrupt context.</a>
<a name="ln329"> *</a>
<a name="ln330"> * Schedules the processing of data to be executed outside of interrupt context.</a>
<a name="ln331"> *</a>
<a name="ln332"> * @param data Incoming bytes.</a>
<a name="ln333"> * @param data_len Length of incoming bytes.</a>
<a name="ln334"> */</a>
<a name="ln335">#ifndef CEEDLING</a>
<a name="ln336">static</a>
<a name="ln337">#endif</a>
<a name="ln338">void on_gatt_received_isr (void * data, size_t data_len)</a>
<a name="ln339">{</a>
<a name="ln340">    ruuvi_driver_status_t err_code = RUUVI_DRIVER_SUCCESS;</a>
<a name="ln341">    LOG (&quot;GATT RX ISR\r\n&quot;);</a>
<a name="ln342">    err_code |= ruuvi_interface_scheduler_event_put (data, data_len,</a>
<a name="ln343">                &amp;process_gatt_command);</a>
<a name="ln344">    RUUVI_DRIVER_ERROR_CHECK (err_code, ~RUUVI_DRIVER_ERROR_FATAL);</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347"> </a>
<a name="ln348">/** @brief Handle outgoing NUS data event.</a>
<a name="ln349"> *</a>
<a name="ln350"> * This function gets called once data queued to NUS is actually sent.</a>
<a name="ln351"> *</a>
<a name="ln352"> * @param data Unused, contains event data which is NULL.</a>
<a name="ln353"> * @param data_len Unused, always 0.</a>
<a name="ln354"> */</a>
<a name="ln355">#ifndef CEEDLING</a>
<a name="ln356">static</a>
<a name="ln357">#endif</a>
<a name="ln358">void on_gatt_sent_isr (void * data, size_t data_len)</a>
<a name="ln359">{</a>
<a name="ln360">    LOG (&quot;GATT TX ISR\r\n&quot;);</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">#ifndef CEEDLING</a>
<a name="ln364">static</a>
<a name="ln365">#endif</a>
<a name="ln366">ruuvi_driver_status_t get_mac (uint8_t * const mac_buffer)</a>
<a name="ln367">{</a>
<a name="ln368">    ruuvi_driver_status_t status = RUUVI_DRIVER_SUCCESS;</a>
<a name="ln369"> </a>
<a name="ln370">    if (NULL != mac_buffer)</a>
<a name="ln371">    {</a>
<a name="ln372">        uint64_t mac;</a>
<a name="ln373">        status |= ruuvi_interface_communication_radio_address_get (&amp;mac);</a>
<a name="ln374">        mac_buffer[0U] = (mac &gt;&gt; 40U) &amp; 0xFFU;</a>
<a name="ln375">        mac_buffer[1U] = (mac &gt;&gt; 32U) &amp; 0xFFU;</a>
<a name="ln376">        mac_buffer[2U] = (mac &gt;&gt; 24U) &amp; 0xFFU;</a>
<a name="ln377">        mac_buffer[3U] = (mac &gt;&gt; 16U) &amp; 0xFFU;</a>
<a name="ln378">        mac_buffer[4U] = (mac &gt;&gt; 8U) &amp; 0xFFU;</a>
<a name="ln379">        mac_buffer[5U] = (mac &gt;&gt; 0U) &amp; 0xFFU;</a>
<a name="ln380">    }</a>
<a name="ln381">    else</a>
<a name="ln382">    {</a>
<a name="ln383">        status = RUUVI_DRIVER_ERROR_NULL;</a>
<a name="ln384">    }</a>
<a name="ln385"> </a>
<a name="ln386">    return status;</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">static void init_dfu (void)</a>
<a name="ln390">{</a>
<a name="ln391">    ruuvi_driver_status_t status = RUUVI_DRIVER_SUCCESS;</a>
<a name="ln392">    status = task_gatt_dfu_init();</a>
<a name="ln393">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">/**</a>
<a name="ln397"> * @brief Initialize Device Information Service</a>
<a name="ln398"> *</a>
<a name="ln399"> * DIS lets user read basic device information over BLE in a standard format.</a>
<a name="ln400"> */</a>
<a name="ln401">static void init_dis (void)</a>
<a name="ln402">{</a>
<a name="ln403">    ruuvi_driver_status_t status = RUUVI_DRIVER_SUCCESS;</a>
<a name="ln404">    ruuvi_interface_communication_ble4_gatt_dis_init_t dis;</a>
<a name="ln405">    memset (&amp;dis, 0U, sizeof (ruuvi_interface_communication_ble4_gatt_dis_init_t));</a>
<a name="ln406">    uint8_t mac_buffer[6U] = {0};</a>
<a name="ln407">    get_mac (mac_buffer);</a>
<a name="ln408">    size_t index = 0U;</a>
<a name="ln409"> </a>
<a name="ln410">    for (size_t ii = 0U; ii &lt; 6U; ii ++)</a>
<a name="ln411">    {</a>
<a name="ln412">        index += snprintf (dis.deviceid + index, sizeof (dis.deviceid) - index, &quot;%02X&quot;,</a>
<a name="ln413">                           mac_buffer[ii]);</a>
<a name="ln414"> </a>
<a name="ln415">        if (ii &lt; 5U)</a>
<a name="ln416">        {</a>
<a name="ln417">            index += snprintf (dis.deviceid + index, sizeof (dis.deviceid) - index, &quot;:&quot;);</a>
<a name="ln418">        }</a>
<a name="ln419">    }</a>
<a name="ln420"> </a>
<a name="ln421">    memcpy (dis.fw_version, APPLICATION_FW_VERSION, sizeof (APPLICATION_FW_VERSION));</a>
<a name="ln422">    memcpy (dis.model, RUUVI_BOARD_MODEL_STRING, sizeof (RUUVI_BOARD_MODEL_STRING));</a>
<a name="ln423">    memcpy (dis.manufacturer, RUUVI_BOARD_MANUFACTURER_STRING,</a>
<a name="ln424">            sizeof (RUUVI_BOARD_MANUFACTURER_STRING));</a>
<a name="ln425">    status |= task_gatt_dis_init (&amp;dis);</a>
<a name="ln426">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">static void init_nus (void)</a>
<a name="ln430">{</a>
<a name="ln431">    ruuvi_driver_status_t status = RUUVI_DRIVER_SUCCESS;</a>
<a name="ln432">    status = task_gatt_nus_init();</a>
<a name="ln433">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln434">}</a>
<a name="ln435">#endif</a>
<a name="ln436"> </a>
<a name="ln437">#if APPLICATION_BUTTON_ENABLED</a>
<a name="ln438">/**</a>
<a name="ln439"> * @brief Handler for button events</a>
<a name="ln440"> *</a>
<a name="ln441"> * @param[in] event Type of button event.</a>
<a name="ln442"> */</a>
<a name="ln443">#ifndef CEEDLING</a>
<a name="ln444">static</a>
<a name="ln445">#endif</a>
<a name="ln446">void button_on_event_isr (const ruuvi_interface_gpio_evt_t event)</a>
<a name="ln447">{</a>
<a name="ln448">    // No functionality right now</a>
<a name="ln449">}</a>
<a name="ln450">#endif</a>
<a name="ln451"> </a>
<a name="ln452">/**</a>
<a name="ln453"> * @brief initialize 2-way communication with outside world.</a>
<a name="ln454"> *</a>
<a name="ln455"> * The communication includes any way user can input data, such as button presses,</a>
<a name="ln456"> * GATT, BLE advertisements and NFC. It does not include inter-board communication</a>
<a name="ln457"> * such as I2C and SPI.</a>
<a name="ln458"> */</a>
<a name="ln459">#ifndef CEEDLING</a>
<a name="ln460">static</a>
<a name="ln461">#endif</a>
<a name="ln462">void init_comms (void)</a>
<a name="ln463">{</a>
<a name="ln464">    ruuvi_driver_status_t status = RUUVI_DRIVER_SUCCESS;</a>
<a name="ln465">#if APPLICATION_BUTTON_ENABLED</a>
<a name="ln466">    // Initialize button with on_button task - TODO @ojousima: Use #defined slope</a>
<a name="ln467">    status = task_button_init (&amp;button_on_event_isr);</a>
<a name="ln468">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln469">#endif</a>
<a name="ln470">#if APPLICATION_COMMUNICATION_ADVERTISING_ENABLED</a>
<a name="ln471">    // Initialize BLE - and start advertising.</a>
<a name="ln472">    status = task_advertisement_init();</a>
<a name="ln473">    status |= task_advertisement_start();</a>
<a name="ln474">    status |= task_communication_heartbeat_configure (</a>
<a name="ln475">                  APPLICATION_ADVERTISEMENT_UPDATE_INTERVAL_MS,</a>
<a name="ln476">                  RUUVI_INTERFACE_COMMUNICATION_MESSAGE_MAX_LENGTH,</a>
<a name="ln477">                  task_sensor_encode_to_5, task_advertisement_send_data);</a>
<a name="ln478">    // Synchronize ADC to radio activity</a>
<a name="ln479">    ruuvi_interface_communication_radio_activity_callback_set (on_radio);</a>
<a name="ln480">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln481">#endif</a>
<a name="ln482">#if APPLICATION_COMMUNICATION_GATT_ENABLED</a>
<a name="ln483">    uint8_t mac_buffer[6U] = {0};</a>
<a name="ln484">    get_mac (mac_buffer);</a>
<a name="ln485">    char name_buffer[SCAN_RSP_NAME_MAX_LEN];</a>
<a name="ln486">    snprintf (name_buffer, sizeof (name_buffer), &quot;%s %02X%02X&quot;,</a>
<a name="ln487">              RUUVI_BOARD_BLE_NAME_STRING,</a>
<a name="ln488">              mac_buffer[sizeof (mac_buffer) - 2],</a>
<a name="ln489">              mac_buffer[sizeof (mac_buffer) - 1]);</a>
<a name="ln490">    status = task_gatt_init (name_buffer);</a>
<a name="ln491">    init_dis();</a>
<a name="ln492">    init_nus();</a>
<a name="ln493">    init_dfu();</a>
<a name="ln494">    task_gatt_set_on_connected_isr (&amp;on_gatt_connected_isr);</a>
<a name="ln495">    task_gatt_set_on_disconn_isr (&amp;on_gatt_disconnected_isr);</a>
<a name="ln496">    task_gatt_set_on_received_isr (&amp;on_gatt_received_isr);</a>
<a name="ln497">    task_gatt_set_on_sent_isr (&amp;on_gatt_sent_isr);</a>
<a name="ln498">    status |= task_gatt_enable();</a>
<a name="ln499">    status |= task_advertisement_stop();  // Reinitialize with scan response</a>
<a name="ln500">    status |= task_advertisement_start();</a>
<a name="ln501">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln502">#endif</a>
<a name="ln503">#if APPLICATION_COMMUNICATION_NFC_ENABLED</a>
<a name="ln504">    // Initialize nfc. Note that NFC requires initialized radio to get</a>
<a name="ln505">    // radio address.</a>
<a name="ln506">    status |= task_nfc_init();</a>
<a name="ln507">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln508">#endif</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511">// Init logging</a>
<a name="ln512">static void init_logging (void)</a>
<a name="ln513">{</a>
<a name="ln514">    ruuvi_driver_status_t status = RUUVI_DRIVER_SUCCESS;</a>
<a name="ln515">    status |= ruuvi_interface_log_init (APPLICATION_LOG_LEVEL);</a>
<a name="ln516">    RUUVI_DRIVER_ERROR_CHECK (status, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln517">    char version[LOG_BUF_SIZE];</a>
<a name="ln518">    ruuvi_interface_log (RUUVI_INTERFACE_LOG_INFO, &quot;Program start\r\n&quot;);</a>
<a name="ln519">    snprintf (version, sizeof (version), &quot;Version: %s\r\n&quot;, APPLICATION_FW_VERSION);</a>
<a name="ln520">    ruuvi_interface_log (RUUVI_INTERFACE_LOG_INFO, version);</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523">/** @brief Actual main, redirected for Ceedling</a>
<a name="ln524"> *</a>
<a name="ln525"> * Initializes logging, MCU peripherals, sensors and communication.</a>
<a name="ln526"> * If all steps are complete without warnings, activity led is set to status_ok, else</a>
<a name="ln527"> * activity led is set to status_error.</a>
<a name="ln528"> *</a>
<a name="ln529"> */</a>
<a name="ln530">int app_main (void)</a>
<a name="ln531">{</a>
<a name="ln532">    ruuvi_driver_status_t err_code = RUUVI_DRIVER_SUCCESS;</a>
<a name="ln533">    init_logging();   // Initializes logging to user console</a>
<a name="ln534">    run_mcu_tests();  // Runs tests which do not rely on MCU peripherals being initialized</a>
<a name="ln535">    init_mcu();       // Initialize MCU peripherals, except for communication with users.</a>
<a name="ln536">    // Delay one second to make sure timestamps are &gt; 1 s after initialization</a>
<a name="ln537">    ruuvi_interface_delay_ms (BOOT_DELAY_MS);</a>
<a name="ln538">    err_code |= task_led_write (RUUVI_BOARD_LED_RED,</a>
<a name="ln539">                                true); // Turn activity led on</a>
<a name="ln540">    run_sensor_tests(); // Run tests which rely on MCU peripherals, e.g. sensor drivers</a>
<a name="ln541">    init_sensors();     // Initializes sensors with application-defined default mode.</a>
<a name="ln542">    // Initialize communication with outside world - BLE, NFC, Buttons</a>
<a name="ln543">    /* IMPORTANT! After this point pausing the program flow asserts,</a>
<a name="ln544">     * since softdevice asserts on missed timer. This includes debugger.</a>
<a name="ln545">     */</a>
<a name="ln546">    // run comms tests - TODO @ojousima</a>
<a name="ln547">    init_comms();</a>
<a name="ln548">    // Turn activity led off. Turn status_ok led on if no errors occured</a>
<a name="ln549">    err_code |= task_led_write (RUUVI_BOARD_LED_RED, false);</a>
<a name="ln550"> </a>
<a name="ln551">    if (RUUVI_DRIVER_SUCCESS == ruuvi_driver_errors_clear())</a>
<a name="ln552">    {</a>
<a name="ln553">        err_code |= task_led_write (RUUVI_BOARD_LED_STATUS_OK, true);</a>
<a name="ln554">        err_code |= task_led_activity_led_set (RUUVI_BOARD_LED_STATUS_OK);</a>
<a name="ln555">        ruuvi_interface_delay_ms (BOOT_DELAY_MS);</a>
<a name="ln556">    }</a>
<a name="ln557">    else</a>
<a name="ln558">    {</a>
<a name="ln559">        err_code |= task_led_write (RUUVI_BOARD_LED_STATUS_ERROR, true);</a>
<a name="ln560">        err_code |= task_led_activity_led_set (RUUVI_BOARD_LED_STATUS_ERROR);</a>
<a name="ln561">        ruuvi_interface_delay_ms (BOOT_DELAY_MS);</a>
<a name="ln562">    }</a>
<a name="ln563"> </a>
<a name="ln564">    // Turn LEDs off</a>
<a name="ln565">    err_code |= task_led_write (RUUVI_BOARD_LED_STATUS_OK, false);</a>
<a name="ln566">    err_code |= task_led_write (RUUVI_BOARD_LED_STATUS_ERROR, false);</a>
<a name="ln567">    // Configure activity indication</a>
<a name="ln568">    ruuvi_interface_yield_indication_set (&amp;task_led_activity_indicate);</a>
<a name="ln569">    RUUVI_DRIVER_ERROR_CHECK (err_code, RUUVI_DRIVER_SUCCESS);</a>
<a name="ln570"> </a>
<a name="ln571">    do</a>
<a name="ln572">    {</a>
<a name="ln573">        // Execute scheduled tasks</a>
<a name="ln574">        ruuvi_interface_scheduler_execute();</a>
<a name="ln575">        // Sleep - woken up on event</a>
<a name="ln576">        ruuvi_interface_yield();</a>
<a name="ln577">    } while (LOOP_FOREVER);</a>
<a name="ln578"> </a>
<a name="ln579">    // Intentionally non-reachable code.</a>
<a name="ln580">    return -1;</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">#ifndef CEEDLING</a>
<a name="ln584">int main (void)</a>
<a name="ln585">{</a>
<a name="ln586">    // Will never return.</a>
<a name="ln587">    return app_main();</a>
<a name="ln588">}</a>
<a name="ln589">#endif</a>
<a name="ln590"> </a>
<a name="ln591">/*@}*/</a>

</code></pre>
<div class="balloon" rel="130"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '1' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="130"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The '(1 << 31)' operand of the '~' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="232"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '1' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="235"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '1' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="260"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '1' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="260"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The '(1 << 31)' operand of the '~' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="248"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2537/" target="_blank">V2537</a> Functions should not have unused parameters. Consider inspecting the parameter: 'data'.</p></div>
<div class="balloon" rel="248"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2537/" target="_blank">V2537</a> Functions should not have unused parameters. Consider inspecting the parameter: 'data_len'.</p></div>
<div class="balloon" rel="283"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '1' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="283"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The '(1 << 31)' operand of the '~' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="271"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2537/" target="_blank">V2537</a> Functions should not have unused parameters. Consider inspecting the parameter: 'data'.</p></div>
<div class="balloon" rel="271"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2537/" target="_blank">V2537</a> Functions should not have unused parameters. Consider inspecting the parameter: 'data_len'.</p></div>
<div class="balloon" rel="321"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '1' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="321"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The right operand '(1 << 9)' of the '|=' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="324"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '1' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="324"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The '(1 << 31)' operand of the '~' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="297"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2009/" target="_blank">V2009</a> Consider rendering the 'p_event_data' pointer as a pointer to const.</p></div>
<div class="balloon" rel="344"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '1' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="344"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The '(1 << 31)' operand of the '~' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="338"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2009/" target="_blank">V2009</a> Consider rendering the 'data' pointer as a pointer to const.</p></div>
<div class="balloon" rel="356"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2537/" target="_blank">V2537</a> Functions should not have unused parameters. Consider inspecting the parameter: 'data'.</p></div>
<div class="balloon" rel="356"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2537/" target="_blank">V2537</a> Functions should not have unused parameters. Consider inspecting the parameter: 'data_len'.</p></div>
<div class="balloon" rel="383"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '1' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="538"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '0' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="549"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '0' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="553"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '0' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="554"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '0' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="559"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '0' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="560"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '0' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="565"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '0' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="566"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '0' of the '<<' operator should not have the essential 'signed' type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
